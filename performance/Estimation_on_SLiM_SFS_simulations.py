"""
runs an analysis of estimator bias and variance on simulations done by Simulate_SFS_with_SLiM.py
(can also run on files generated by simulate_WF_SFSs_for_SFRatios.py run with -s)

expects filenames like   csfs_selected.txt and csfs_neutral.txt

For a range of true values of the selection coefficient g or of the density of g

usage: Estimation_on_SLiM_SFS_simulations.py [-h] [-c FIX_THETA_RATIO] [-b] [-d DENSITYOF2NS] [-s SEED] -f FOLDSTATUS [-i OPTIMIZETRIES] [-k NTRIALS]
                                             -l FILELABEL [-m MAX2NS] -n NC [-p] [-a THETANSPACERANGE] [-q THETAS] [-t THETAN] [-w] [-F CSFSPREFIX]
                                             [-M MAXI] [-D] [-O OUTPUT_DIR] -W SLIM_SFSS_DIR [--profile]

options:
  -h, --help           show this help message and exit
  -c FIX_THETA_RATIO   set the fixed value of thetaS/thetaN
  -b                   run the dual annealing optimizer after the regular optimizer
  -d DENSITYOF2NS      gamma or lognormal, only if simulating a distribution of Ns, else single values of Ns are used
  -s SEED              random number seed (positive integer)
  -f FOLDSTATUS        usage regarding folded or unfolded SFS distribution, 'isfolded', 'foldit' or 'unfolded'
  -i OPTIMIZETRIES     run the minimize optimizer # times, default is once
  -k NTRIALS           number of trials per parameter set
  -l FILELABEL         string for labelling file names
  -m MAX2NS            maximum 2Ns, default = 1
  -n NC                # of sampled chromosomes i.e. 2*(# diploid individuals)
  -p                   include a misspecification parameter (only for unfolded data)
  -a THETANSPACERANGE  optional setting for the range of thetaNspace, alternatives e.g. 25, 400
  -q THETAS            theta for selected sites
  -t THETAN            set theta for neutral sites, optional, if -t is not specified then thetaN and thetaS are given by -q
  -w                   do not estimate both thetas, just the ratio
  -F CSFSPREFIX        optional prefix for csfs filenames, e.g. Afr, Eur or EAs
  -M MAXI              optional setting for the maximum bin index to include in the calculations
  -D                   debug
  -O OUTPUT_DIR        Path for output directory
  -W SLIM_SFSS_DIR     Path for directory with simulations from Simulate_SFS_with_SLiM.py
  --profile            Enable profiling, default is off
  
Expects files simulated by Simulate_SFS_with_SLiM.py 
"""

import sys
import math
import argparse
import os
import os.path as op
import random
import time
import numpy as np
from scipy.stats import norm
from scipy.optimize import minimize,minimize_scalar
from  scipy.optimize import basinhopping, brentq,dual_annealing
from scipy.stats import chi2
current_dir = op.dirname(os.path.abspath(__file__)) # the directory of this python script
parent_dir = op.dirname(current_dir)  # the parent directory 
# Add the parent and current directories to sys.path
sys.path.append(current_dir)
sys.path.append(parent_dir)

# Add the directory containing utilities to sys.path
sys.path.append(op.join(parent_dir,'./utilities'))


import SFRatios_functions as SFRf 


# import warnings
# warnings.filterwarnings("ignore")

# as of 8/23/2023 Kuethe method does not work as well

# optimizemethod="Powell"  #this just does not seem to do very well 
# also tried BFGS using a calculated jacobian,  but it was incredibly slow and ran into nan errors 
optimizemethod="Nelder-Mead" # this works best but not perfect,  take the best of 3 calls 
np.seterr(divide='ignore', invalid='ignore')

DEBUGMODE = False 
JH_turn_off_options_for_release = True  # use this to turn off obscure options not for the release of this program. 
JH_turn_off_options_for_release = False

def makeSFScomparisonstring(headers,sfslist):
    slist = []
    slist.append("\t".join(headers) + "\n")
    n = len(sfslist[0])
    k = len(sfslist)
    for i in range(n):
        if k ==6:
            temp = ["{}".format(sfslist[0][i]),"{}".format(sfslist[1][i]),"{:.3g}".format(float(sfslist[2][i])),"{}".format(sfslist[3][i]),"{}".format(sfslist[4][i]),"{:.3g}".format(float(sfslist[5][i]))]
        else:
            temp = ["{}".format(sfslist[j][i]) for j in range(k)]
        temp.insert(0,str(i))
        slist.append("\t\t" + "\t".join(temp)+"\n")
    slist.append("\n")   
    return ''.join(slist) 


def extract_float(s):
    """ 
    to get the float in a string that looks like this: # 4Nmu(exon total length)=1036.8 distribution=lognormal dist_pars=[0.3, 0.5] n=100 Selected folded SFS
    """
    parts = s.split()  # Split the string into parts separated by spaces
    for part in parts:
        if "=" in part: # and part[0].isdigit():
            # Split at '=' and take the second part, then convert to float
            num_part = part.split('=')[1]
            try:
                return float(num_part)
            except ValueError:
                pass  # Ignore if the conversion fails and continue
    return None  # Return None if no float is found


def getslimgeneratedratios(args,slim_SFSs_dir,nc, foldstatus,densityof2Ns,maxi = None):
    """
        gets sfss that were previously generated by simulate_SFS_withSLiM.py running SLiM
    """
    if DEBUGMODE:
        if densityof2Ns =="lognormal":
            gvalstrs = [["0.3","0.5"]]
        elif densityof2Ns == "gamma":
            gvalstrs = [["-1.0","1.0"]]
            # gvalstrs = [["3.0","4.0"],["5.0","11.0"],["6.0","51.0"]]
        elif densityof2Ns  == "fixed2Ns":
            gvalstrs = [["-10.0"]]            

    else:

        if densityof2Ns == "lognormal":
            # gvalstrs = [["0.3","0.5"], ["1.0","0.7"], ["2.0","1.0"], ["2.2","1.4"], ["3.0","1.2"]]
            # gvalstrs = [["0.3","0.5"], ["1.0","0.7"], ["2.0","1.0"], ["3.0","1.2"]]
            # gvalstrs = [["5.8","1.5"]]
            gvalstrs = [["0.3","0.5"], ["1.0","0.7"], ["2.0","1.0"], ["3.0","1.2"],["5.8","1.5"]]
        elif densityof2Ns == "gamma":
            # gvalstrs = [["2.0","2.0"],["3.0","4.0"],["5.0","11.0"],["6.0","51.0"]]
            # gvalstrs = [["4.0","1.5"],["3.0","3.5"],["1.5","12.0"],["1.0","41.0"]]
            # gvalstrs = [["4.0","1.5"],["3.0","3.5"],["1.5","12.0"],["1.0","41.0"]]
            # gvalstrs = [["-1.0","1.0"],["-5.0","5.0"],["-50.0","4.0"],["-100.0","2.0"]]
            # gvalstrs = [["-1000.0","0.5"]]
            gvalstrs = [["-1.0","1.0"],["-5.0","5.0"],["-50.0","4.0"],["-100.0","2.0"],["-1000.0","0.5"]]
            
        elif densityof2Ns == "normal":
            exit()
        elif densityof2Ns == "fixed2Ns":
            # gvalstrs = [["-50.0"],["-10.0"],["-5.0"],["-1.0"],["0.0"],["1.0"],["5.0"],["10.0"],["50.0"]]
            # gvalstrs = [["-1000"],["-500"],["-100"],["-50"],["-10"],["-5"],["-1"],["0"],["1"],["5"],["10"]]
            gvalstrs = [["-1000.0"],["-500.0"],["-100.0"],["-50.0"],["-10.0"],["-5.0"],["-1.0"],["0.0"],["1.0"],["5.0"],["10.0"]]
            # gvalstrs = [["-100.0"],["-50.0"],["-10.0"],["-5.0"],["-1.0"],["0.0"],["1.0"],["5.0"],["10.0"]]
    
    gvals = [list(map(float,temp)) for temp in gvalstrs]

    minNval = 0.99 if args.dontkeepzeroratios else 0  # if args.dontkeepzeroratios is True,  then any numerator value <= 0.99 will cause a ratio of inf 
    numdatasets = len(gvalstrs)
    ssfslists = [[] for i in range(numdatasets)]
    nsfslists = [[] for i in range(numdatasets)]
    ratiolists = [[] for i in range(numdatasets)]
    truethetaNlist = [[] for i in range(numdatasets)]
    truethetaSlist = [[]for i in range(numdatasets)]
    
    # for di,d in enumerate(gdirs):
    for di,g in enumerate(gvalstrs):
        if densityof2Ns in ("normal","lognormal","gamma","discrete3"):
            tempdir = op.join(slim_SFSs_dir,"{}-{}".format(g[0],g[1]))
        else:
            tempdir = op.join(slim_SFSs_dir,"{}".format(g[0]))
        if args.csfsprefix is not None:
            sfile = op.join(tempdir,args.csfsprefix + "_csfs_selected.txt")
            nfile = op.join(tempdir,args.csfsprefix + "_csfs_neutral.txt")
        else:
            sfile = op.join(tempdir,"csfs_selected.txt")
            nfile = op.join(tempdir,"csfs_neutral.txt")
        nlines = open(nfile,'r').readlines() 
        slines = open(sfile,'r').readlines() 
        if args.truethetaN is not None:
            temptruethetaN = args.truethetaN
        elif args.truethetaS is not None:
            temptruethetaN = args.truethetaS
        else:
            temptruethetaN = extract_float(slines[0])
        truethetaNlist[di].append(temptruethetaN)
        # Find the index of the first string that begins with a number
        xi = next((i for i, s in enumerate(nlines) if s.strip() and s[0].isdigit()), len(nlines))
        nsfss = nlines[xi:]
        slines = open(sfile,'r').readlines() 
        truethetaSlist[di].append(extract_float(slines[0]) if args.truethetaS == None else args.truethetaS)
        # Find the index of the first string that begins with a number
        xi = next((i for i, s in enumerate(slines) if s.strip() and s[0].isdigit()), len(slines))
        ssfss = slines[xi:]
        numdatarows = len(nsfss)
        assert len(ssfss)==numdatarows
        if DEBUGMODE:
            numdatarows = 1
        for i in range(numdatarows):
            neutvals = list(map(float,nsfss[i].strip().split()))
            selectvals = list(map(float,ssfss[i].strip().split()))
            assert len(neutvals)==len(selectvals)
            nbins = len(selectvals) 
            if foldstatus=="isfolded":
                assert nbins == 1+nc//2,"# of sfs bins {} not consistent with -f {} and reported sample size -n {}".format(nbins,foldstatus,nc)
            if foldstatus in ("unfolded", "foldit"):
                assert nbins == 1+nc,"# of sfs bins {} not consistent with -f {} and reported sample size -n {}".format(nbins,foldstatus,nc)
                neutvals=neutvals[:-1]
                selectvals = selectvals[:-1]
                if foldstatus == "foldit":
                    selectvals = [0] + [selectvals[j]+selectvals[nc-j] for j in range(1,nc//2)] + [selectvals[nc//2]]
                    neutvals = [0] + [neutvals[j]+neutvals[nc-j] for j in range(1,nc//2)] + [neutvals[nc//2]]
            if maxi and maxi < len(selectvals):
                selectvals = selectvals[:maxi+1]
                neutvals = neutvals[:maxi+1]
            ssfslists[di].append(selectvals)
            nsfslists[di].append(neutvals)
            ratiolists[di].append([math.inf if neutvals[j] <= minNval else selectvals[j]/neutvals[j] for j in range(len(neutvals))])
            assert len(ratiolists[di])==len(nsfslists[di])
    
    return numdatarows,gvalstrs,ssfslists,nsfslists,ratiolists,truethetaNlist,truethetaSlist

def boundarycheck(x, bounds):
    check = False
    for i,val in enumerate(x):
        check = check or math.isclose(val,bounds[i][0])
        check = check or math.isclose(val,bounds[i][1])
        if check:
            break
    return check

def set_bounds_and_start_possibilities(args,thetaNest,thetaSest,ntrials):
    """
        bounds for each model,  with a series of random start values 
        boundary values are based on a lot of hunches, trial and error 
    """
    bounds = []
    startvals = [[] for _ in range(ntrials)]
    thetaratioest = thetaSest/thetaNest
    bounds.append((thetaratioest/20,thetaratioest*20))
    for sv in startvals: sv.append(random.uniform(thetaratioest/3,thetaratioest*3))
    if args.densityof2Ns == "lognormal":
        bounds += [(-5,10),(0.01,5)]
        for sv in startvals: sv.append(random.uniform(0.3,3))
        for sv in startvals: sv.append(random.uniform(0.5,1.5))
    elif args.densityof2Ns =="gamma":
        bounds += [(-10000,-0.5),(0.5,10)]        
        for sv in startvals: sv.append(random.uniform(-10,-1))
        for sv in startvals: sv.append(random.uniform(0.5,2))
    elif args.densityof2Ns=="normal":
        # bounds += [(-50,20),(0.1,10)]
        bounds += [(-50,20),(0.1,20)]
        for sv in startvals: sv.append(random.uniform(-15,1))
        for sv in startvals: sv.append(random.uniform(0.2,4))
    elif args.densityof2Ns=="discrete3":
        bounds += [(0.0,1.0),(0.0,1.0)]
        for sv in startvals: sv.append(random.uniform(0.1,0.4))
        for sv in startvals: sv.append(random.uniform(0.1,0.4))
    else:# otherwise density == "fixed2Ns"
        bounds += [(-2000,100)]
        for sv in startvals: sv.append(random.uniform(-10,1))
    # if args.estimate_pointmass0:
    #     bounds += [(0.0,0.5)]
    #     # bounds += [(0.0,0.99)]
    #     for sv in startvals: sv.append(random.uniform(0.01,0.49))
    if args.estimatemax2Ns:
        bounds += [(-20.0,20.0)]
        for sv in startvals: sv.append(random.uniform(-5,1))
    if args.use_misspec:
        bounds += [(0.0,0.2)] # assume misspecification rate is less than 0.2 
        for sv in startvals: sv.append(random.uniform(0.001,0.1))
    return bounds,startvals 

def run(args):
    global DEBUGMODE 
    if args.DEBUGMODE:
        DEBUGMODE = True 
    starttime = time.time()
    np.random.seed(args.seed)
    ntrialsperg = args.ntrials
    densityof2Ns = args.densityof2Ns 
    foldstatus = args.foldstatus
    usedualannealing = args.dualannealopt
    fix_theta_ratio = args.fix_theta_ratio
    use_misspec = args.use_misspec
    maxi = args.maxi
    estimatemax2Ns = True if  args.max2Ns is None and args.densityof2Ns != "fixed2Ns" and args.densityof2Ns != "normal" else False
    args.estimatemax2Ns = estimatemax2Ns
    fixedmax2Ns = args.max2Ns
    if not os.path.exists(args.output_dir):
        os.makedirs(args.output_dir)
    dofoldedlikelihood = foldstatus in ('isfolded','foldit')
    nc = args.nc

    slim_SFSs_dir = args.slim_SFSs_dir


    
    ntrialsperg,gvals,ssfslists,nsfslists,ratiolists,truethetaNlist,truethetaSlist = getslimgeneratedratios(args,slim_SFSs_dir,nc,foldstatus,densityof2Ns,maxi=args.maxi)
    if hasattr(args, "ntrials") and args.ntrials is not None and args.ntrials < ntrialsperg:
        ntrialsperg = args.ntrials

    basename = op.join(args.output_dir,args.filelabel + "_" + op.split(slim_SFSs_dir)[-1])
    print(basename)
    if densityof2Ns != "fixed2Ns":
        ln1results = []
        ln2results = []
        allgresults = []
    else:
        gresults = []

    foldstring = "folded" if foldstatus else "unfolded"
    SFScomparesultsstrings = []
    
    if densityof2Ns != "fixed2Ns":
        gvalsfor2Dplotsnames = "{}_gvals_for_2D_plot.txt".format(basename)
        
    else:
        gvalsforplotnames = "{}_gvals_for_plot.txt".format(basename)
    estimates_filename = '{}_results.txt'.format(basename)    
    

    thetaNresults = []
    thetaSresults = []
    thetaratioresults = []
    savedSFSS = [[] for i in range(len(gvals))]  
    savedSFSN = [[] for i in range(len(gvals))]     
    savedDataRatios = [[] for i in range(len(gvals))]
    if estimatemax2Ns:
        max2Nsresults = []
    if use_misspec:
        misspecresults = []
    func = SFRf.NegL_SFSRATIO_estimate_thetaratio
    basearglist = [nc,dofoldedlikelihood,use_misspec,densityof2Ns,fix_theta_ratio,fixedmax2Ns,False,False] 
    successntrialsperg = []
    for gi,g in enumerate(gvals):
        # print(g)
        thetaSresults.append([])
        thetaNresults.append([])
        thetaratioresults.append([])
        if estimatemax2Ns:
            max2Nsresults.append([])
        if use_misspec:
            misspecresults.append([])
        if densityof2Ns in ("normal","lognormal","gamma","discrete3"):
            ln1results.append([])
            ln2results.append([])
            allgresults.append([[],[]])
        else:
            gresults.append([])
        successntrialsperg.append(0)
        for i in range(ntrialsperg):
            # print(i)
            if densityof2Ns in ("normal","lognormal","gamma","discrete3"):
                SFScompareheaders = ["Params:{} {} Trial#{}:".format(g[0],g[1],i+1),"Nsim","Ssim","Ratiosim","Nfit","Sfit","Ratiofit"]
            else:
                SFScompareheaders = ["2Ns:{} Trial#{}:".format(g,i+1),"Nsim","Ssim","Ratiosim","Nfit","Sfit","Ratiofit"]
            nsfs = nsfslists[gi][i]
            ssfs = ssfslists[gi][i]
            ratios = ratiolists[gi][i]
            thetaNest = sum(nsfs)/sum([1/i for i in range(1,nc)]) # this should work whether or not the sfs is folded 
            thetaSest = sum(ssfs)/sum([1/i for i in range(1,nc)]) # this should work whether or not the sfs is folded 
            # thetaNspace = np.logspace(np.log10(thetaNest/math.sqrt(args.thetaNspacerange)), np.log10(thetaNest*math.sqrt(args.thetaNspacerange)), num=101) # used for likelihood calculation,  logspace integrates bettern than linspace
            #shorter version, 51 instead of 101, seems to work 
            thetaNspace = np.logspace(np.log10(thetaNest/math.sqrt(args.thetaNspacerange)), np.log10(thetaNest*math.sqrt(args.thetaNspacerange)), num=101) # used for likelihood calculation,  logspace integrates bettern than linspace
            thetaratioest = thetaSest/thetaNest
            arglist = list(basearglist)
            arglist.append(thetaNspace)
            arglist.append(ratios)
            # do ntries optimzation attempts and pick the best one 
            ntries = args.optimizetries 
            bounds,startarrays = set_bounds_and_start_possibilities(args,thetaNest,thetaSest,ntries)
            rxvals = []
            rfunvals = []
            # print(bounds)
            for ii in range(ntries):
                startarray = startarrays[ii]
                result = minimize(func,np.array(startarray),args=tuple(arglist),method=optimizemethod,bounds=bounds)             
                # from scipy.optimize import OptimizeResult
                # result = OptimizeResult(x=[2.1862,3.9806,0.43651],fun=-2.283,message = "debugging")            
                rxvals.append(result)
                rfunvals.append(-result.fun)
                if DEBUGMODE:
                    if densityof2Ns != "fixed2Ns":
                        print("{} {} #{} >{} {:.5f} {}".format(g[0],g[1],i,ii,-result.fun,result.x))
                    else:
                        print("{} #{} >{} {:.5f} {}".format(g,i,ii,-result.fun,result.x))
            besti = rfunvals.index(max(rfunvals))
            result = rxvals[besti]
            # print("opt",result)
            atboundary = boundarycheck(result.x, bounds)
            if usedualannealing: #  or (atboundary and DEBUGMODE==False):
                
                boundsarray = bounds
                # use result.x to set bounds and start search
                # startarray = [min(bounds[i][1],max(bounds[i][0],random.uniform(v/1.5,v*1.5))) for i,v in enumerate(result.x) ] #won't work if v is 0 
                startarray = startarrays[besti]
                # print(args.slim_SFSs_dir,result.x,"\n",boundsarray,"\n",startarray)
                # da_result = dual_annealing(func,np.array(startarray),T=10.0,
                #                 minimizer_kwargs={"method":optimizemethod,"bounds":boundsarray,"args":arglist})
                da_result = dual_annealing(func,boundsarray,args=arglist)
                # print("Da",da_result)
                if DEBUGMODE:
                    if densityof2Ns != "fixed2Ns":
                        print("{} {} #{} >{} {:.5f} {}".format(g[0],g[1],i,ii,-da_result.fun,da_result.x))
                    else:
                        print("{} #{} >{} {:.5f} {}".format(g,i,ii,-da_result.fun,da_result.x))
                if -da_result.fun > -result.fun:
                    result = da_result
            pi = 0
            # okrun = result.x[0] < 1.0
            okrun = True
            if okrun:
                successntrialsperg[gi] += 1
                if densityof2Ns != "fixed2Ns":
                    if fix_theta_ratio: 
                        tempratio = fix_theta_ratio
                    else:
                        tempratio = result.x[pi]
                        pi+= 1
                    thetaratioresults[gi].append(tempratio)
                    allgresults[gi][0].append(result.x[pi])
                    allgresults[gi][1].append(result.x[pi+1])
                    ln1results[gi].append(result.x[pi])
                    ln2results[gi].append(result.x[pi+1])
                    thetaNresults[gi].append(thetaNest)
                    thetaSresults[gi].append(tempratio*thetaNest)
                    pi+= 2
                    # if estimatemax2Ns:
                    #     max2Nsresults[gi].append(result.x[pi])
                    #     pi+=1
                    if estimatemax2Ns:
                        if use_misspec:
                            max2Nsresults[gi].append(result.x[-2])
                            misspecresults[gi].append(result.x[-1])
                        else:
                            max2Nsresults[gi].append(result.x[-2])
                    elif use_misspec:
                        misspecresults[gi].append(result.x[-1])                        
                    if use_misspec:
                        fitnsfs,fitssfs,fitratios =  SFRf.simsfsratio(thetaNresults[gi][-1],thetaSresults[gi][-1],fixedmax2Ns,nc,args.maxi,dofoldedlikelihood,misspecresults[gi][-1],densityof2Ns,[ln1results[gi][-1],ln2results[gi][-1]],None,True,tempratio)
                    else:
                        fitnsfs,fitssfs,fitratios =  SFRf.simsfsratio(thetaNresults[gi][-1],thetaSresults[gi][-1],fixedmax2Ns,nc,args.maxi,dofoldedlikelihood,None,densityof2Ns,[ln1results[gi][-1],ln2results[gi][-1]],None,True,tempratio)
                else:
                    if fix_theta_ratio: 
                        tempratio = fix_theta_ratio
                    else:
                        tempratio = result.x[pi]
                        pi+= 1
                    thetaratioresults[gi].append(tempratio)
                    gresults[gi].append(result.x[pi])
                    thetaNresults[gi].append(thetaNest)
                    thetaSresults[gi].append(tempratio*thetaNest)
                    if use_misspec:
                        misspecresults[gi].append(result.x[-1]) 
                        fitnsfs,fitssfs,fitratios =  SFRf.simsfsratio(thetaNresults[gi][-1],thetaSresults[gi][-1],fixedmax2Ns,nc,args.maxi,dofoldedlikelihood,misspecresults[gi][-1],densityof2Ns,[gresults[gi][-1]],None,True,tempratio)
                    else:
                        fitnsfs,fitssfs,fitratios =  SFRf.simsfsratio(thetaNresults[gi][-1],thetaSresults[gi][-1],fixedmax2Ns,nc,args.maxi,dofoldedlikelihood,None,densityof2Ns,[gresults[gi][-1]],None,True,tempratio)
            SFScomparesultsstrings.append(makeSFScomparisonstring(SFScompareheaders,[nsfs,ssfs,ratios,fitnsfs,fitssfs,fitratios]))
            savedSFSS[gi].append(ssfs)
            savedSFSN[gi].append(nsfs)
            savedDataRatios[gi].append(ratios)
        # print("done")
        print(f"finished pid {args.pid} parameter set {gi}.")
    f = open(estimates_filename,"w")
    f.write("Program Estimation_on_SFS_with_SLiM.py results:\n\nCommand line arguments:\n=======================\n")
    for key, value in vars(args).items():
        f.write("\t{}: {}\n".format(key,value))
    f.write("\nCompare simulated and fitted SFS:\n=================================\n")
    f.write(''.join(SFScomparesultsstrings))

    # f = open(estimates_filename,"a")
    f.write("Parameter Estimates:\n===================\n")
    
    for gi,g in enumerate(gvals):
        if densityof2Ns != "fixed2Ns":
            if estimatemax2Ns:  # as of 1/8/2024 all simulations use max2Ns = 1.0
                if truethetaNlist[gi][0] == None or truethetaSlist[gi][0]==None:
                    f.write("\tSet {} Values:\t\tThetaRatio UNKNOWN\t\tg1 {}\t\tg2 {}\t\tmax2Ns {}\n".format(gi+1,g[0],g[1],1.0))
                else:
                    f.write("\tSet {} Values:\t\tThetaRatio {}\t\tg1 {}\t\tg2 {}\t\tmax2Ns {}\n".format(gi+1,truethetaSlist[gi][0]/truethetaNlist[gi][0],g[0],g[1],1.0))
                for k in range(successntrialsperg[gi]):
                    f.write("\t\t{}\t\t{:.4g}\t\t{:.2g}\t\t{:.2g}\t\t{:.4g}\n".format(k+1,thetaratioresults[gi][k],ln1results[gi][k],ln2results[gi][k],max2Nsresults[gi][k])) 
                f.write("\tMean:\t\t{:.2g}\t\t{:.2g}\t\t{:.2g}\t\t{:.4g}\n".format(np.mean(np.array(thetaratioresults[gi])),np.mean(np.array(ln1results[gi])),np.mean(np.array(ln2results[gi])),np.mean(np.array(max2Nsresults[gi]))))
                f.write("\tStDev:\t\t{:.2g}\t\t{:.2g}\t\t{:.2g}\t\t{:.4g}\n".format(np.std(np.array(thetaratioresults[gi])),np.std(np.array(ln1results[gi])),np.std(np.array(ln2results[gi])),np.std(np.array(max2Nsresults[gi]))))
            elif use_misspec:
                if truethetaNlist[gi][0] == None or truethetaSlist[gi][0]==None:
                    f.write("\tSet {} Values:\t\tThetaRatio UNKNOWN\t\tg1 {}\t\tg2 {}\t\tmisspec \n".format(gi+1,g[0],g[1]))
                else:
                    f.write("\tSet {} Values:\t\tThetaRatio {}\t\tg1 {}\t\tg2 {}\t\tmisspec\n".format(gi+1,truethetaSlist[gi][0]/truethetaNlist[gi][0],g[0],g[1]))
                for k in range(successntrialsperg[gi]):
                    f.write("\t\t{}\t\t{:.4g}\t\t{:.2g}\t\t{:.2g}\t\t{:.4g}\n".format(k+1,thetaratioresults[gi][k],ln1results[gi][k],ln2results[gi][k],misspecresults[gi][k])) 
                f.write("\tMean:\t\t{:.2g}\t\t{:.2g}\t\t{:.2g}\t\t{:.4g}\n".format(np.mean(np.array(thetaratioresults[gi])),np.mean(np.array(ln1results[gi])),np.mean(np.array(ln2results[gi])),np.mean(np.array(misspecresults[gi]))))
                f.write("\tStDev:\t\t{:.2g}\t\t{:.2g}\t\t{:.2g}\t\t{:.4g}\n".format(np.std(np.array(thetaratioresults[gi])),np.std(np.array(ln1results[gi])),np.std(np.array(ln2results[gi])),np.std(np.array(misspecresults[gi]))))                    

            else:
                if truethetaNlist[gi][0] == None or truethetaSlist[gi][0]==None:
                    f.write("\tSet {} Values:\t\tThetaRatio UNKNOWN\t\tg1 {}\t\tg2 {}\n".format(gi+1,g[0],g[1]))
                else:
                    f.write("\tSet {} Values:\t\tThetaRatio {}\t\tg1 {}\t\tg2 {}\n".format(gi+1,truethetaSlist[gi][0]/truethetaNlist[gi][0],g[0],g[1]))
                for k in range(successntrialsperg[gi]):
                    f.write("\t\t{}\t\t{:.4g}\t\t{:.2g}\t\t{:.2g}\n".format(k+1,thetaratioresults[gi][k],ln1results[gi][k],ln2results[gi][k]))
                f.write("\tMean:\t\t{:.2g}\t\t{:.2g}\t\t{:.2g}\n".format(np.mean(np.array(thetaratioresults[gi])),np.mean(np.array(ln1results[gi])),np.mean(np.array(ln2results[gi]))))
                f.write("\tStDev:\t\t{:.2g}\t\t{:.2g}\t\t{:.2g}\n".format(np.std(np.array(thetaratioresults[gi])),np.std(np.array(ln1results[gi])),np.std(np.array(ln2results[gi]))))
        else:
            f.write("\tSet {} Values:\t\tThetaRatio {}\t\tg {}\n".format(gi+1,truethetaSlist[gi][0]/truethetaNlist[gi][0],g))
            for k in range(successntrialsperg[gi]):
                try:
                    f.write("\t\t{}\t\t{:.4g}\t\t{:.2g}\n".format(k+1,thetaratioresults[gi][k],gresults[gi][k]))
                except Exception as e:
                    print(e)
                    print(gi,k,k+1)
                    print(thetaratioresults[gi])
                    print(gresults[gi])
                    exit()
            f.write("\tMean:\t\t{:.2g}\t\t{:.2g}\n".format(np.mean(np.array(thetaratioresults[gi])),np.mean(np.array(gresults[gi]))))
            f.write("\tStDev:\t\t{:.3g}\t\t{:.2g}\n".format(np.std(np.array(thetaratioresults[gi])),np.std(np.array(gresults[gi]))))
    f.write("\n\n")
    f.write("Mean SFS Counts For Each Parameter Set (Neutral, Selected, Ratio):\n==================================================================\n")     
    f.write("Selection parameter sets: {}\n".format(" ".join(list(map(str,gvals)))))
    for gi in range(len(gvals)):   
        f.write("\tNeutral\tSelect\tRatio")
    f.write("\n")
    for i in range(len(savedSFSS[0][0])):
        f.write("{}".format(i))
        for gi in range(len(gvals)):
            ntemp = sum([savedSFSN[gi][j][i] for j in range (successntrialsperg[gi])])/successntrialsperg[gi]
            stemp = sum([savedSFSS[gi][j][i] for j in range (successntrialsperg[gi])])/successntrialsperg[gi]
            rtemp = sum([savedDataRatios[gi][j][i] for j in range (successntrialsperg[gi])])/successntrialsperg[gi]
            f.write("\t{:.2g}\t{:.2g}\t{:.3g}".format(ntemp,stemp,rtemp))
        f.write("\n")
    endtime = time.time()
    total_seconds = endtime-starttime
    hours = int(total_seconds // 3600)
    minutes = int((total_seconds % 3600) // 60)
    seconds = total_seconds % 60
    f.write(f"\nTime taken: {hours} hours, {minutes} minutes, {seconds:.2g} seconds\n")            
    f.close()        
    if densityof2Ns != "fixed2Ns":
        gf = open(gvalsfor2Dplotsnames,'w')
        for gi,g in enumerate(gvals):
            gf.write("{}\t".format(g[0]))
            for i in range(len(allgresults[gi][0])):
                gf.write("{} ".format(allgresults[gi][0][i]))
            gf.write("\n")
            gf.write("{}\t".format(g[1]))
            for i in range(len(allgresults[gi][1])):
                gf.write("{} ".format(allgresults[gi][1][i]))
            gf.write("\n\n")                
        gf.close()

    else:
        gf = open(gvalsforplotnames,'w')
        for gi,g in enumerate(gvals):
            gf.write("{}\t".format(g[0]))
            for i in range(len(gresults[gi])):
                gf.write("{} ".format(gresults[gi][i]))
            gf.write("\n\n")                
        gf.close()            
        tempgvals = []
        for gi,g in enumerate(gvals):
            tempgvals.append(float(g[0]))
    print("done {}".format(basename))    


def parsecommandline():
    parser = argparse.ArgumentParser()
    parser.add_argument("-c",dest="fix_theta_ratio",default=None,type=float,help="set the fixed value of thetaS/thetaN")
    parser.add_argument("-b",dest="dualannealopt",action="store_true",default=False,help="run the dual annealing optimizer after the regular optimizer")
    parser.add_argument("-d",dest="densityof2Ns",default = "fixed2Ns",type=str,help="gamma or lognormal, only if simulating a distribution of Ns, else single values of Ns are used")
    parser.add_argument("-s",dest="seed",type = int,help = " random number seed (positive integer)",default=1)    
    parser.add_argument("-f",dest="foldstatus",required=True,help="usage regarding folded or unfolded SFS distribution, 'isfolded', 'foldit' or 'unfolded' ")    
    parser.add_argument("-i",dest="optimizetries",type=int,default=1,help="run the minimize optimizer # times, default is once")
    parser.add_argument("-k",dest="ntrials",default = 20, type = int, help="number of trials per parameter set")    
    parser.add_argument("-l",dest="filelabel",required = True, type=str, help="string for labelling file names ")    
    parser.add_argument("-m",dest="max2Ns",default=1.0,type=float,help="maximum 2Ns, default = 1  ")
    parser.add_argument("-n",dest="nc",type = int, required=True,help="# of sampled chromosomes  i.e. 2*(# diploid individuals)  ")
    if JH_turn_off_options_for_release == False:
        parser.add_argument("-p",dest = "use_misspec",action="store_true",default = False,help="include a misspecification parameter (only for unfolded data)")
        parser.add_argument("-a",dest="thetaNspacerange",default=100,type=int,help="optional setting for the range of thetaNspace, alternatives e.g. 25, 400")
        parser.add_argument("-F", dest="csfsprefix",default = None,type = str, help="optional prefix for csfs filenames,  e.g. Afr, Eur or EAs")
        parser.add_argument("-M",dest="maxi",default=None,type=int,help="optional setting for the maximum bin index to include in the calculations")
    parser.add_argument("-q",dest="truethetaS",type=float,default = None,help = "true theta for selected sites, if not specified try to get it from the simulation file")   
    parser.add_argument("-t",dest="truethetaN",type=float,default = None,help = "truetheta for neutral sites, optional, if -t is not specified and -q is set,  then thetaN and thetaS are given by -q, else , if not specified try to get it from the simulation file")
    parser.add_argument("-D",dest="DEBUGMODE",action="store_true",default=False,help="debug")
    parser.add_argument("-O", dest="output_dir",default = "./Results_SFS_with_SLiM",type = str, help="Path for output directory")
    parser.add_argument("-W", dest="slim_SFSs_dir",required=True,type = str, help="Path for directory with simulations from Simulate_SFS_with_SLiM.py")
    parser.add_argument("-z",dest="dontkeepzeroratios",action="store_true",default=False,help=" if set, ratio is set to inf if either numerator or denominator is zero") 
    parser.add_argument('--profile', action='store_true', help="Enable profiling, default is off ")    
        
    args  =  parser.parse_args(sys.argv[1:])  
    if JH_turn_off_options_for_release:
        args.use_misspec = False
        args.truethetaS = None
        args.truethetaN = None
        args.csfsprefix = None
        args.maxi = None
        args.thetaNspacerange = 100
    
    if args.densityof2Ns != "fixed2Ns" and not (args.densityof2Ns in ['lognormal','gamma']):
        parser.error("-d term {} is not either 'lognormal' or 'gamma'".format(args.densityof2Ns))
    if args.densityof2Ns== "fixed2Ns" and args.max2Ns != 1.0:
        parser.error("-m requires that a density function be specified (i.e. -d )")    
    if args.foldstatus not in ("isfolded","foldit","unfolded"):
        parser.error("-f {} is wrong,  this tag requires one of 'isfolded','foldit', or 'unfolded'".format(args.foldstatus))
    if args.use_misspec and args.foldstatus != "unfolded":
        parser.error(" use of misspecification (-p) requires that -f be unfolded")
    args.commandstring = " ".join(sys.argv[1:])
    # Get the current process ID
    args.pid = os.getpid()
    return args

    # return parser

if __name__ == '__main__':
    """

    """
    starttime = time.time()
    args = parsecommandline()
    if args.profile:
        import cProfile 
        import pstats
        import io
        from pstats import SortKey
        # Set up the profiler
        profiler = cProfile.Profile()
        profiler.enable()     
    run(args)
    if args.profile:
        profiler.disable()
        
        # Write full program profile stats
        prffilename = 'Estimation_on_SLiM_SFS_simulations_stats_{}.prof'.format(args.filelabel)
        with open(prffilename, 'w') as f:
            stats = pstats.Stats(profiler, stream=f)
            stats.sort_stats('cumulative')
            stats.print_stats()
        print("profile stats written too {}".format(prffilename))
        
        # Filter and write myptools profile stats
        prffilename = 'SFRatios_functions_stats_{}.prof'.format(args.filelabel)
        with open(prffilename, 'w') as f:
            stats = pstats.Stats(profiler, stream=f)
            stats.sort_stats('cumulative')
            stats.print_stats('SFRatios_functions')
        print("SFRatios_functions profile stats written too {}".format(prffilename))
