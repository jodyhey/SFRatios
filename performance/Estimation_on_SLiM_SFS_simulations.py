"""
runs an analysis of estimator bias and variance on simulations done by Simulate_SFS_with_SLiM.py

For a range of true values of the selection coefficient g or of the density of g,  generate boxplots of estimates 

usage: Estimation_on_SLiM_SFS_simulations.py [-h] [-c FIX_THETA_RATIO] [-b] [-d DENSITYOF2NS] -f FOLDSTATUS
                                             [-i OPTIMIZETRIES] [-k NTRIALS] [-l PLOTFILELABEL] [-m MAX2NS] -n NC
                                             [-s SEED] [-D] [-O OUTPUT_DIR] -W SLIM_SFSS_DIR

options:
  -h, --help          show this help message and exit
  -c FIX_THETA_RATIO  set the fixed value of thetaS/thetaN
  -b                  run the basinhopping optimizer after the regular optimizer
  -d DENSITYOF2NS     gamma or lognormal, only if simulating a distribution of Ns, else single values of Ns are used
  -f FOLDSTATUS       usage regarding folded or unfolded SFS distribution, 'isfolded', 'foldit' or 'unfolded'
  -i OPTIMIZETRIES    run the minimize optimizer # times, default is once
  -k NTRIALS          number of trials per parameter set
  -l PLOTFILELABEL    optional string for labelling plot file names
  -m MAX2NS           maximum 2Ns, default = 1
  -n NC               # of sampled chromosomes i.e. 2*(# diploid individuals)
  -s SEED             random number seed (positive integer)
  -D                  debug
  -O OUTPUT_DIR       Path for output directory
  -W SLIM_SFSS_DIR    Path for directory with simulations from Simulate_SFS_with_SLiM.py
  
Expects files simulated by Simulate_SFS_with_SLiM.py 
"""

import sys
import math
import argparse
import os
import os.path as op
import random
import time
import numpy as np
from scipy.stats import norm
import matplotlib.pyplot as plt
from scipy.optimize import minimize,minimize_scalar
from  scipy.optimize import basinhopping, brentq,dual_annealing
from scipy.stats import chi2
current_dir = op.dirname(os.path.abspath(__file__)) # the directory of this python script
parent_dir = op.dirname(current_dir)  # the parent directory 
# Add the parent and current directories to sys.path
sys.path.append(current_dir)
sys.path.append(parent_dir)

# Add the directory containing utilities to sys.path
sys.path.append(op.join(parent_dir,'./utilities'))
import twoDboxplot 
import SF_Ratios_functions

# import warnings
# warnings.filterwarnings("ignore")

# as of 8/23/2023 Kuethe method does not work as well

# optimizemethod="Powell"  #this just does not seem to do very well 
# also tried BFGS using a calculated jacobian,  but it was incredibly slow and ran into nan errors 
optimizemethod="Nelder-Mead" # this works best but not perfect,  take the best of 3 calls 
np.seterr(divide='ignore', invalid='ignore')

DEBUGMODE = False 
JH_turn_off_options_for_release = True  # use this to turn off obscure options not for the release of this program. 
JH_turn_off_options_for_release = False

def makeSFScomparisonstring(headers,sfslist):
    slist = []
    slist.append("\t".join(headers) + "\n")
    n = len(sfslist[0])
    k = len(sfslist)
    for i in range(n):
        if k ==6:
            temp = ["{}".format(sfslist[0][i]),"{}".format(sfslist[1][i]),"{:.3g}".format(float(sfslist[2][i])),"{}".format(sfslist[3][i]),"{}".format(sfslist[4][i]),"{:.3g}".format(float(sfslist[5][i]))]
        else:
            temp = ["{}".format(sfslist[j][i]) for j in range(k)]
        temp.insert(0,str(i))
        slist.append("\t\t" + "\t".join(temp)+"\n")
    slist.append("\n")   
    return ''.join(slist) 


def extract_float(s):
    """ 
    to get the float in a string that looks like this: # 4Nmu(exon total length)=1036.8 distribution=lognormal dist_pars=[0.3, 0.5] n=100 Selected folded SFS
    """
    parts = s.split()  # Split the string into parts separated by spaces
    for part in parts:
        if "=" in part: # and part[0].isdigit():
            # Split at '=' and take the second part, then convert to float
            num_part = part.split('=')[1]
            try:
                return float(num_part)
            except ValueError:
                pass  # Ignore if the conversion fails and continue
    return None  # Return None if no float is found


def getslimgeneratedratios(args,slim_SFSs_dir,nc, foldstatus,densityof2Ns,maxi = None):
    """
        gets sfss that were previously generated by simulate_SFS_withSLiM.py running SLiM
    """
    if DEBUGMODE:
        if densityof2Ns =="lognormal":
            gvalstrs = [["0.3","0.5"]]
        elif densityof2Ns == "gamma":
            # gvalstrs = [["2.0","2.0"]]
            gvalstrs = [["3.0","4.0"],["5.0","11.0"],["6.0","51.0"]]
        elif densityof2Ns  == "fixed2Ns":
            gvalstrs = [["-100.0"]]            

    else:

        if densityof2Ns == "lognormal":
            # gvalstrs = [["0.3","0.5"], ["1.0","0.7"], ["2.0","1.0"], ["2.2","1.4"], ["3.0","1.2"]]
            gvalstrs = [["0.3","0.5"], ["1.0","0.7"], ["2.0","1.0"], ["3.0","1.2"]]
        elif densityof2Ns == "gamma":
            # gvalstrs = [["11.0","0.1"],["8.5","0.2"],["3.86","0.7"],["4.64","1.1"]]
            gvalstrs = [["2.0","2.0"],["3.0","4.0"],["5.0","11.0"],["6.0","51.0"]]
        elif densityof2Ns == "normal":
            exit()
        elif densityof2Ns == "fixed2Ns":
            # gvalstrs = [["-50.0"],["-10.0"],["-5.0"],["-1.0"],["0.0"],["1.0"],["5.0"],["10.0"],["50.0"]]
            gvalstrs = [["-1000.0"],["-500.0"],["-100.0"],["-50.0"],["-10.0"],["-5.0"],["-1.0"],["0.0"],["1.0"],["5.0"],["10.0"]]
    
    gvals = [list(map(float,temp)) for temp in gvalstrs]
    minNval = 0
    numdatasets = len(gvalstrs)
    ssfslists = [[] for i in range(numdatasets)]
    nsfslists = [[] for i in range(numdatasets)]
    ratiolists = [[] for i in range(numdatasets)]
    truethetaNlist = [[] for i in range(numdatasets)]
    truethetaSlist = [[]for i in range(numdatasets)]
    
    # for di,d in enumerate(gdirs):
    for di,g in enumerate(gvalstrs):
        if densityof2Ns in ("normal","lognormal","gamma","discrete3"):
            tempdir = op.join(slim_SFSs_dir,"{}-{}".format(g[0],g[1]))
        else:
            tempdir = op.join(slim_SFSs_dir,"{}".format(g[0]))
        if args.csfsprefix is not None:
            sfile = op.join(tempdir,args.csfsprefix + "_csfs_selected.txt")
            nfile = op.join(tempdir,args.csfsprefix + "_csfs_neutral.txt")
        else:
            sfile = op.join(tempdir,"csfs_selected.txt")
            nfile = op.join(tempdir,"csfs_neutral.txt")
        nlines = open(nfile,'r').readlines() 
        truethetaNlist[di].append(extract_float(nlines[0]))
        # 4Nmu(exon total length)=1036.8 distribution=lognormal dist_pars=[0.3, 0.5] n=100 Selected folded SFS
        nsfss = nlines[1:]
        slines = open(sfile,'r').readlines() 
        truethetaSlist[di].append(extract_float(slines[0]))
        ssfss = slines[1:]
        numdatarows = len(nsfss)
        assert len(ssfss)==numdatarows
        for i in range(numdatarows):
            neutvals = list(map(float,nsfss[i].strip().split()))
            selectvals = list(map(float,ssfss[i].strip().split()))
            assert len(neutvals)==len(selectvals)
            nbins = len(selectvals) 
            if foldstatus=="isfolded":
                assert nbins == 1+nc//2,"# of sfs bins {} not consistent with -f {} and reported sample size -n {}".format(nbins,foldstatus,nc)
            if foldstatus in ("unfolded", "foldit"):
                assert nbins == 1+nc,"# of sfs bins {} not consistent with -f {} and reported sample size -n {}".format(nbins,foldstatus,nc)
                neutvals=neutvals[:-1]
                selectvals = selectvals[:-1]
                if foldstatus == "foldit":
                    selectvals = [0] + [selectvals[j]+selectvals[nc-j] for j in range(1,nc//2)] + [selectvals[nc//2]]
                    neutvals = [0] + [neutvals[j]+neutvals[nc-j] for j in range(1,nc//2)] + [neutvals[nc//2]]
            if maxi and maxi < len(selectvals):
                selectvals = selectvals[:maxi+1]
                neutvals = neutvals[:maxi+1]
            ssfslists[di].append(selectvals)
            nsfslists[di].append(neutvals)
            ratiolists[di].append([math.inf if neutvals[j] <= minNval else selectvals[j]/neutvals[j] for j in range(len(neutvals))])
            assert len(ratiolists[di])==len(nsfslists[di])
    
    return numdatarows,gvalstrs,ssfslists,nsfslists,ratiolists,truethetaNlist,truethetaSlist

def boundarycheck(x, bounds):
    check = False
    for i,val in enumerate(x):
        check = check or math.isclose(val,bounds[i][0])
        check = check or math.isclose(val,bounds[i][1])
        if check:
            break
    return check

def set_bounds_and_start_possibilities(args,thetaNest,thetaSest,ntrials):
    """
        bounds for each model,  with a series of random start values 
        boundary values are based on a lot of hunches, trial and error 
    """
    bounds = []
    startvals = [[] for _ in range(ntrials)]
    if not args.fix_theta_ratio:
        if args.use_theta_ratio:
            thetaratioest = thetaSest/thetaNest
            bounds.append((thetaratioest/20,thetaratioest*20))
            for sv in startvals: sv.append(random.uniform(thetaratioest/3,thetaratioest*3))
        else:
            bounds.append((thetaNest/30,thetaNest*30))
            for sv in startvals: sv.append(random.uniform(thetaNest/10,thetaNest*10))
            bounds.append((thetaSest/30,thetaSest*30))
            for sv in startvals: sv.append(random.uniform(thetaSest/10,thetaSest*10))
    if args.densityof2Ns == "lognormal":
        bounds += [(-5,10),(0.01,5)]
        for sv in startvals: sv.append(random.uniform(0.3,3))
        for sv in startvals: sv.append(random.uniform(0.5,1.5))
    elif args.densityof2Ns =="gamma":
        bounds += [(0.5,40),(0.5,10000)]        
        for sv in startvals: sv.append(random.uniform(1,5))
        for sv in startvals: sv.append(random.uniform(0.1,2))
    elif args.densityof2Ns=="normal":
        # bounds += [(-50,20),(0.1,10)]
        bounds += [(-50,20),(0.1,20)]
        for sv in startvals: sv.append(random.uniform(-15,1))
        for sv in startvals: sv.append(random.uniform(0.2,4))
    elif args.densityof2Ns=="discrete3":
        bounds += [(0.0,1.0),(0.0,1.0)]
        for sv in startvals: sv.append(random.uniform(0.1,0.4))
        for sv in startvals: sv.append(random.uniform(0.1,0.4))
    else:# otherwise density == "fixed2Ns"
        bounds += [(-1000,1000)]
        for sv in startvals: sv.append(random.uniform(-10,1))
    # if args.estimate_pointmass0:
    #     bounds += [(0.0,0.5)]
    #     # bounds += [(0.0,0.99)]
    #     for sv in startvals: sv.append(random.uniform(0.01,0.49))
    # if args.estimate_pointmass:
    #     # bounds += [(0.0,0.5),(-10.0, 10.0)]        
    #     bounds += [(0.0,0.5),(-20.0, 20.0)]        
    #     for sv in startvals: sv.append(random.uniform(0.01,0.49))
    #     for sv in startvals: sv.append(random.uniform(-5,1))
    if args.estimatemax2Ns:
        bounds += [(-20.0,20.0)]
        for sv in startvals: sv.append(random.uniform(-5,1))
    if args.use_misspec:
        bounds += [(0.0,0.2)] # assume misspecification rate is less than 0.2 
        for sv in startvals: sv.append(random.uniform(0.001,0.1))
    return bounds,startvals 

def run(args):
    global DEBUGMODE 
    if args.DEBUGMODE:
        DEBUGMODE = True 

    starttime = time.time()
    np.random.seed(args.seed)
    ntrialsperg = args.ntrials
    densityof2Ns = args.densityof2Ns 
    foldstatus = args.foldstatus
    usedualannealing = args.dualannealopt
    use_theta_ratio = args.use_theta_ratio
    fix_theta_ratio = args.fix_theta_ratio
    use_misspec = args.use_misspec
    maxi = args.maxi
    estimatemax2Ns = True if  args.max2Ns is None and args.densityof2Ns != "fixed2Ns" and args.densityof2Ns != "normal" else False
    args.estimatemax2Ns = estimatemax2Ns
    fixedmax2Ns = args.max2Ns
    if not os.path.exists(args.output_dir):
        os.makedirs(args.output_dir)
    dofoldedlikelihood = foldstatus in ('isfolded','foldit')
    nc = args.nc

    slim_SFSs_dir = args.slim_SFSs_dir


    
    ntrialsperg,gvals,ssfslists,nsfslists,ratiolists,truethetaNlist,truethetaSlist = getslimgeneratedratios(args,slim_SFSs_dir,nc,foldstatus,densityof2Ns,maxi=args.maxi)
    if hasattr(args, "ntrials") and args.ntrials is not None and args.ntrials < ntrialsperg:
        ntrialsperg = args.ntrials
        # print(ntrialsperg)
    # if args.plotfilelabel == "":
    #     basename = op.join(args.output_dir,slim_SFSs_dir.strip(".").replace("/","_").strip("_"))
    # else:
    #     basename = op.join(args.output_dir,args.plotfilelabel + slim_SFSs_dir.strip(".").replace("/","_"))
    if args.plotfilelabel == "":
        basename = op.join(args.output_dir,op.split(slim_SFSs_dir)[-1])
    else:
        basename = op.join(args.output_dir,args.plotfilelabel + "_" + op.split(slim_SFSs_dir)[-1])
    print(basename)
    if densityof2Ns != "fixed2Ns":
        ln1results = []
        ln2results = []
        allgresults = []
    else:
        gresults = []

    foldstring = "folded" if foldstatus else "unfolded"
    SFScomparesultsstrings = []
    
    if densityof2Ns != "fixed2Ns":
        plotfile1name = '{}_term1_plot.png'.format(basename)
        plotfile2name = '{}_term2_plot.png'.format(basename)
        plotfile2Dname = '{}_2Dplot.png'.format(basename)
        gvalsfor2Dplotsnames = "{}_gvals_for_2D_plot.txt".format(basename)
        
    else:
        plotfilename = '{}_2Ns_plot.png'.format(basename)
        gvalsforplotnames = "{}_gvals_for_plot.txt".format(basename)
    estimates_filename = '{}_results.txt'.format(basename)    
    

    thetaNresults = []
    thetaSresults = []
    thetaratioresults = []
    savedSFSS = [[] for i in range(len(gvals))]  
    savedSFSN = [[] for i in range(len(gvals))]     
    savedDataRatios = [[] for i in range(len(gvals))]
    if estimatemax2Ns:
        max2Nsresults = []
    if use_misspec:
        misspecresults = []
    if use_theta_ratio:
        func = SF_Ratios_functions.NegL_SFSRATIO_estimate_thetaratio
        basearglist = [nc,dofoldedlikelihood,use_misspec,densityof2Ns,fix_theta_ratio,fixedmax2Ns,False,False,False,False] 
    else:
        func = SF_Ratios_functions.NegL_SFSRATIO_estimate_thetaS_thetaN
        basearglist = [nc,dofoldedlikelihood,use_misspec,densityof2Ns,False,fixedmax2Ns,False,False,False]

    successntrialsperg = []
    for gi,g in enumerate(gvals):
        # print(g)
        thetaSresults.append([])
        thetaNresults.append([])
        if use_theta_ratio:
            thetaratioresults.append([])
        if estimatemax2Ns:
            max2Nsresults.append([])
        if use_misspec:
            misspecresults.append([])
        if densityof2Ns in ("normal","lognormal","gamma","discrete3"):
            ln1results.append([])
            ln2results.append([])
            allgresults.append([[],[]])
        else:
            gresults.append([])
        successntrialsperg.append(0)
        for i in range(ntrialsperg):
            # print(i)
            if densityof2Ns in ("normal","lognormal","gamma","discrete3"):
                SFScompareheaders = ["Params:{} {} Trial#{}:".format(g[0],g[1],i+1),"Nsim","Ssim","Ratiosim","Nfit","Sfit","Ratiofit"]
            else:
                SFScompareheaders = ["2Ns:{} Trial#{}:".format(g,i+1),"Nsim","Ssim","Ratiosim","Nfit","Sfit","Ratiofit"]
            nsfs = nsfslists[gi][i]
            ssfs = ssfslists[gi][i]
            ratios = ratiolists[gi][i]
            thetaNest = sum(nsfs)/sum([1/i for i in range(1,nc)]) # this should work whether or not the sfs is folded 
            thetaSest = sum(ssfs)/sum([1/i for i in range(1,nc)]) # this should work whether or not the sfs is folded 
            thetaNspace = np.logspace(np.log10(thetaNest/math.sqrt(args.thetaNspacerange)), np.log10(thetaNest*math.sqrt(args.thetaNspacerange)), num=101) # used for likelihood calculation,  logspace integrates bettern than linspace
            thetaratioest = thetaSest/thetaNest
            arglist = list(basearglist)
            arglist.append(thetaNspace)
            arglist.append(ratios)





            # do ntries optimzation attempts and pick the best one 
            ntries = args.optimizetries 
            bounds,startarrays = set_bounds_and_start_possibilities(args,thetaNest,thetaSest,ntries)
            rxvals = []
            rfunvals = []
            # print(bounds)
            for ii in range(ntries):
                startarray = startarrays[ii]
                result = minimize(func,np.array(startarray),args=tuple(arglist),method=optimizemethod,bounds=bounds)             
                # from scipy.optimize import OptimizeResult
                # result = OptimizeResult(x=[2.1862,3.9806,0.43651],fun=-2.283,message = "debugging")            
                rxvals.append(result)
                rfunvals.append(-result.fun)
                if DEBUGMODE:
                    if densityof2Ns != "fixed2Ns":
                        print("{} {} #{} >{} {:.5f} {}".format(g[0],g[1],i,ii,-result.fun,result.x))
                    else:
                        print("{} #{} >{} {:.5f} {}".format(g,i,ii,-result.fun,result.x))
            besti = rfunvals.index(max(rfunvals))
            result = rxvals[besti]
            # print("opt",result)
            atboundary = boundarycheck(result.x, bounds)
            if usedualannealing: #  or (atboundary and DEBUGMODE==False):
                
                boundsarray = bounds
                # use result.x to set bounds and start search
                # startarray = [min(bounds[i][1],max(bounds[i][0],random.uniform(v/1.5,v*1.5))) for i,v in enumerate(result.x) ] #won't work if v is 0 
                startarray = startarrays[besti]
                # print(args.slim_SFSs_dir,result.x,"\n",boundsarray,"\n",startarray)
                # da_result = dual_annealing(func,np.array(startarray),T=10.0,
                #                 minimizer_kwargs={"method":optimizemethod,"bounds":boundsarray,"args":arglist})
                da_result = dual_annealing(func,boundsarray,args=arglist)
                # print("Da",da_result)
                if -da_result.fun > -result.fun:
                    result = da_result
            pi = 0
            # okrun = result.x[0] < 1.0
            okrun = True
            if okrun:
                successntrialsperg[gi] += 1
                if densityof2Ns != "fixed2Ns":
                    if use_theta_ratio:
                        if fix_theta_ratio: 
                            tempratio = fix_theta_ratio
                        else:
                            tempratio = result.x[pi]
                            pi+= 1
                        thetaratioresults[gi].append(tempratio)
                        allgresults[gi][0].append(result.x[pi])
                        allgresults[gi][1].append(result.x[pi+1])
                        ln1results[gi].append(result.x[pi])
                        ln2results[gi].append(result.x[pi+1])
                        thetaNresults[gi].append(thetaNest)
                        thetaSresults[gi].append(tempratio*thetaNest)
                        pi+= 2
                        # if estimatemax2Ns:
                        #     max2Nsresults[gi].append(result.x[pi])
                        #     pi+=1
                        if estimatemax2Ns:
                            if use_misspec:
                                max2Nsresults[gi].append(result.x[-2])
                                misspecresults[gi].append(result.x[-1])
                            else:
                                max2Nsresults[gi].append(result.x[-2])
                        elif use_misspec:
                            misspecresults[gi].append(result.x[-1])                        
                    else:
                        allgresults[gi][0].append(result.x[2])
                        allgresults[gi][1].append(result.x[3])
                        ln1results[gi].append(result.x[2])
                        ln2results[gi].append(result.x[3])
                        thetaNresults[gi].append(result.x[0])
                        thetaSresults[gi].append(result.x[1])
                        tempratio = None
                        if estimatemax2Ns:
                            if use_misspec:
                                max2Nsresults[gi].append(result.x[-2])
                                misspecresults[gi].append(result.x[-1])
                            else:
                                max2Nsresults[gi].append(result.x[-2])
                        elif use_misspec:
                            misspecresults[gi].append(result.x[-1])
                    if use_misspec:
                        fitnsfs,fitssfs,fitratios =  SF_Ratios_functions.simsfsratio(thetaNresults[gi][-1],thetaSresults[gi][-1],fixedmax2Ns,nc,args.maxi,dofoldedlikelihood,misspecresults[gi][-1],densityof2Ns,[ln1results[gi][-1],ln2results[gi][-1]],None,True,tempratio)
                    else:
                        fitnsfs,fitssfs,fitratios =  SF_Ratios_functions.simsfsratio(thetaNresults[gi][-1],thetaSresults[gi][-1],fixedmax2Ns,nc,args.maxi,dofoldedlikelihood,None,densityof2Ns,[ln1results[gi][-1],ln2results[gi][-1]],None,True,tempratio)
                else:
                    if use_theta_ratio:
                        if fix_theta_ratio: 
                            tempratio = fix_theta_ratio
                        else:
                            tempratio = result.x[pi]
                            pi+= 1
                        thetaratioresults[gi].append(tempratio)
                        gresults[gi].append(result.x[pi])
                        thetaNresults[gi].append(thetaNest)
                        thetaSresults[gi].append(tempratio*thetaNest)
                        if use_misspec:
                            misspecresults[gi].append(result.x[-1]) 
                            fitnsfs,fitssfs,fitratios =  SF_Ratios_functions.simsfsratio(thetaNresults[gi][-1],thetaSresults[gi][-1],fixedmax2Ns,nc,args.maxi,dofoldedlikelihood,misspecresults[gi][-1],densityof2Ns,[gresults[gi][-1]],None,True,tempratio)
                        else:
                            fitnsfs,fitssfs,fitratios =  SF_Ratios_functions.simsfsratio(thetaNresults[gi][-1],thetaSresults[gi][-1],fixedmax2Ns,nc,args.maxi,dofoldedlikelihood,None,densityof2Ns,[gresults[gi][-1]],None,True,tempratio)
                    else:
                        gresults[gi].append(result.x[2])
                        thetaNresults[gi].append(result.x[0])
                        thetaSresults[gi].append(result.x[1])
                        if use_misspec:
                            misspecresults[gi].append(result.x[-1]) 
                            fitnsfs,fitssfs,fitratios =  SF_Ratios_functions.simsfsratio(thetaNresults[gi][-1],thetaSresults[gi][-1],fixedmax2Ns,nc,args.maxi,dofoldedlikelihood,misspecresults[gi][-1],densityof2Ns,[gresults[gi][-1]],None,True,None)
                        else:
                            fitnsfs,fitssfs,fitratios =  SF_Ratios_functions.simsfsratio(thetaNresults[gi][-1],thetaSresults[gi][-1],fixedmax2Ns,nc,args.maxi,dofoldedlikelihood,None,densityof2Ns,[gresults[gi][-1]],None,True,None)
            SFScomparesultsstrings.append(makeSFScomparisonstring(SFScompareheaders,[nsfs,ssfs,ratios,fitnsfs,fitssfs,fitratios]))
            savedSFSS[gi].append(ssfs)
            savedSFSN[gi].append(nsfs)
            savedDataRatios[gi].append(ratios)
        # print("done")
    f = open(estimates_filename,"w")
    f.write("Program Estimation_on_SFS_with_SLiM.py results:\n\nCommand line arguments:\n=======================\n")
    for key, value in vars(args).items():
        f.write("\t{}: {}\n".format(key,value))
    f.write("\nCompare simulated and fitted SFS:\n=================================\n")
    f.write(''.join(SFScomparesultsstrings))

    # f = open(estimates_filename,"a")
    f.write("Parameter Estimates:\n===================\n")
    
    for gi,g in enumerate(gvals):
        if densityof2Ns != "fixed2Ns":
            if use_theta_ratio:
                if estimatemax2Ns:  # as of 1/8/2024 all simulations use max2Ns = 1.0
                    if truethetaNlist[gi][0] == None or truethetaSlist[gi][0]==None:
                        f.write("\tSet {} Values:\t\tThetaRatio UNKNOWN\t\tg1 {}\t\tg2 {}\t\tmax2Ns {}\n".format(gi+1,g[0],g[1],1.0))
                    else:
                        f.write("\tSet {} Values:\t\tThetaRatio {}\t\tg1 {}\t\tg2 {}\t\tmax2Ns {}\n".format(gi+1,truethetaSlist[gi][0]/truethetaNlist[gi][0],g[0],g[1],1.0))
                    for k in range(successntrialsperg[gi]):
                        f.write("\t\t{}\t\t{:.4g}\t\t{:.2g}\t\t{:.2g}\t\t{:.4g}\n".format(k+1,thetaratioresults[gi][k],ln1results[gi][k],ln2results[gi][k],max2Nsresults[gi][k])) 
                    f.write("\tMean:\t\t{:.2g}\t\t{:.2g}\t\t{:.2g}\t\t{:.4g}\n".format(np.mean(np.array(thetaratioresults[gi])),np.mean(np.array(ln1results[gi])),np.mean(np.array(ln2results[gi])),np.mean(np.array(max2Nsresults[gi]))))
                    f.write("\tStDev:\t\t{:.2g}\t\t{:.2g}\t\t{:.2g}\t\t{:.4g}\n".format(np.std(np.array(thetaratioresults[gi])),np.std(np.array(ln1results[gi])),np.std(np.array(ln2results[gi])),np.std(np.array(max2Nsresults[gi]))))
                elif use_misspec:
                    if truethetaNlist[gi][0] == None or truethetaSlist[gi][0]==None:
                        f.write("\tSet {} Values:\t\tThetaRatio UNKNOWN\t\tg1 {}\t\tg2 {}\t\tmisspec \n".format(gi+1,g[0],g[1]))
                    else:
                        f.write("\tSet {} Values:\t\tThetaRatio {}\t\tg1 {}\t\tg2 {}\t\tmisspec\n".format(gi+1,truethetaSlist[gi][0]/truethetaNlist[gi][0],g[0],g[1]))
                    for k in range(successntrialsperg[gi]):
                        f.write("\t\t{}\t\t{:.4g}\t\t{:.2g}\t\t{:.2g}\t\t{:.4g}\n".format(k+1,thetaratioresults[gi][k],ln1results[gi][k],ln2results[gi][k],misspecresults[gi][k])) 
                    f.write("\tMean:\t\t{:.2g}\t\t{:.2g}\t\t{:.2g}\t\t{:.4g}\n".format(np.mean(np.array(thetaratioresults[gi])),np.mean(np.array(ln1results[gi])),np.mean(np.array(ln2results[gi])),np.mean(np.array(misspecresults[gi]))))
                    f.write("\tStDev:\t\t{:.2g}\t\t{:.2g}\t\t{:.2g}\t\t{:.4g}\n".format(np.std(np.array(thetaratioresults[gi])),np.std(np.array(ln1results[gi])),np.std(np.array(ln2results[gi])),np.std(np.array(misspecresults[gi]))))                    

                else:
                    if truethetaNlist[gi][0] == None or truethetaSlist[gi][0]==None:
                        f.write("\tSet {} Values:\t\tThetaRatio UNKNOWN\t\tg1 {}\t\tg2 {}\n".format(gi+1,g[0],g[1]))
                    else:
                        f.write("\tSet {} Values:\t\tThetaRatio {}\t\tg1 {}\t\tg2 {}\n".format(gi+1,truethetaSlist[gi][0]/truethetaNlist[gi][0],g[0],g[1]))
                    for k in range(successntrialsperg[gi]):
                        f.write("\t\t{}\t\t{:.4g}\t\t{:.2g}\t\t{:.2g}\n".format(k+1,thetaratioresults[gi][k],ln1results[gi][k],ln2results[gi][k]))
                    f.write("\tMean:\t\t{:.2g}\t\t{:.2g}\t\t{:.2g}\n".format(np.mean(np.array(thetaratioresults[gi])),np.mean(np.array(ln1results[gi])),np.mean(np.array(ln2results[gi]))))
                    f.write("\tStDev:\t\t{:.2g}\t\t{:.2g}\t\t{:.2g}\n".format(np.std(np.array(thetaratioresults[gi])),np.std(np.array(ln1results[gi])),np.std(np.array(ln2results[gi]))))
            else:
                if estimatemax2Ns: # as of 1/8/2024 all simulations use max2Ns = 1.0
                    if truethetaNlist[gi][0] == None or truethetaSlist[gi][0]==None:
                        f.write("\tSet {} Values:\t\tThetaS UNKNOWN\t\tThetaN UNKNOWN\t\tg1 {}\t\tg2 {}\t\tmax2Ns {}\n".format(gi+1,g[0],g[1],1.0)) # for truetheta vals all true values are same in a set, se we can use the 0th value
                    else:
                        f.write("\tSet {} Values:\t\tThetaS {}\t\tThetaN {}\t\tg1 {}\t\tg2 {}\t\tmax2Ns\n".format(gi+1,truethetaSlist[gi][0],truethetaNlist[gi][0],g[0],g[1],1.0)) # for truetheta vals all true values are same in a set, se we can use the 0th value
                    for k in range(successntrialsperg[gi]):
                        f.write("\t\t{}\t\t{:.2g}\t\t{:.2g}\t\t{:.2g}\t\t{:.2g}\t\t{:.4g}\n".format(k+1,thetaSresults[gi][k],thetaNresults[gi][k],ln1results[gi][k],ln2results[gi][k],ln2results[gi][k],max2Nsresults[gi][k]))
                    f.write("\tMean:\t\t{:.2g}\t\t{:.2g}\t\t{:.2g}\t\t{:.2g}\t\t{:.4g}\n".format(np.mean(np.array(thetaSresults[gi])),np.mean(np.array(thetaNresults[gi])),np.mean(np.array(ln1results[gi])),np.mean(np.array(ln2results[gi])),np.mean(np.array(max2Nsresults[gi]))))
                    f.write("\tStDev:\t\t{:.2g}\t\t{:.2g}\t\t{:.2g}\t\t{:.2g}\t\t{:.4g}\n".format(np.std(np.array(thetaSresults[gi])),np.std(np.array(thetaNresults[gi])),np.std(np.array(ln1results[gi])),np.std(np.array(ln2results[gi])),np.std(np.array(max2Nsresults[gi]))))
                else:
                    if truethetaNlist[gi][0] == None or truethetaSlist[gi][0]==None:                        
                        f.write("\tSet {} Values:\t\tThetaS UNKNOWN\t\tThetaN UNKNOWN\t\tg1 {}\t\tg2 {}\n".format(gi+1,g[0],g[1])) # for truetheta vals all true values are same in a set, se we can use the 0th value
                    else:
                        f.write("\tSet {} Values:\t\tThetaS {}\t\tThetaN {}\t\tg1 {}\t\tg2 {}\n".format(gi+1,truethetaSlist[gi][0],truethetaNlist[gi][0],g[0],g[1])) # for truetheta vals all true values are same in a set, se we can use the 0th value
                    for k in range(successntrialsperg[gi]):
                        f.write("\t\t{}\t\t{:.2g}\t\t{:.2g}\t\t{:.2g}\t\t{:.2g}\n".format(k+1,thetaSresults[gi][k],thetaNresults[gi][k],ln1results[gi][k],ln2results[gi][k]))
                    f.write("\tMean:\t\t{:.2g}\t\t{:.2g}\t\t{:.2g}\t\t{:.2g}\n".format(np.mean(np.array(thetaSresults[gi])),np.mean(np.array(thetaNresults[gi])),np.mean(np.array(ln1results[gi])),np.mean(np.array(ln2results[gi]))))
                    f.write("\tStDev:\t\t{:.2g}\t\t{:.2g}\t\t{:.2g}\t\t{:.2g}\n".format(np.std(np.array(thetaSresults[gi])),np.std(np.array(thetaNresults[gi])),np.std(np.array(ln1results[gi])),np.std(np.array(ln2results[gi]))))
        
        else:
            if use_theta_ratio:
                f.write("\tSet {} Values:\t\tThetaRatio {}\t\tg {}\n".format(gi+1,truethetaSlist[gi][0]/truethetaNlist[gi][0],g))
                for k in range(successntrialsperg[gi]):
                    try:
                        f.write("\t\t{}\t\t{:.4g}\t\t{:.2g}\n".format(k+1,thetaratioresults[gi][k],gresults[gi][k]))
                    except Exception as e:
                        print(e)
                        print(gi,k,k+1)
                        print(thetaratioresults[gi])
                        print(gresults[gi])
                        exit()
                f.write("\tMean:\t\t{:.2g}\t\t{:.2g}\n".format(np.mean(np.array(thetaratioresults[gi])),np.mean(np.array(gresults[gi]))))
                f.write("\tStDev:\t\t{:.3g}\t\t{:.2g}\n".format(np.std(np.array(thetaratioresults[gi])),np.std(np.array(gresults[gi]))))
            else:
                f.write("\tSet {} Values:\t\tThetaS {}\t\tThetaN {}\t\tg {}\n".format(gi+1,args.thetaS,args.thetaN,g))
                for k in range(successntrialsperg[gi]):
                    f.write("\t\t{}\t\t{:.2g}\t\t{:.2g}\t\t{:.2g}\n".format(k+1,thetaSresults[gi][k],thetaNresults[gi][k],gresults[gi][k]))
                f.write("\tMean:\t\t{:.2g}\t\t{:.2g}\t\t{:.2g}\n".format(np.mean(np.array(thetaSresults[gi])),np.mean(np.array(thetaNresults[gi])),np.mean(np.array(gresults[gi]))))
                f.write("\tStDev:\t\t{:.2g}\t\t{:.2g}\t\t{:.2g}\n".format(np.std(np.array(thetaSresults[gi])),np.std(np.array(thetaNresults[gi])),np.std(np.array(gresults[gi]))))
    f.write("\n\n")
    f.write("Mean SFS Counts For Each Parameter Set (Neutral, Selected, Ratio):\n==================================================================\n")     
    f.write("Selection parameter sets: {}\n".format(" ".join(list(map(str,gvals)))))
    for gi in range(len(gvals)):   
        f.write("\tNeutral\tSelect\tRatio")
    f.write("\n")
    for i in range(len(savedSFSS[0][0])):
        f.write("{}".format(i))
        for gi in range(len(gvals)):
            ntemp = sum([savedSFSN[gi][j][i] for j in range (successntrialsperg[gi])])/successntrialsperg[gi]
            stemp = sum([savedSFSS[gi][j][i] for j in range (successntrialsperg[gi])])/successntrialsperg[gi]
            rtemp = sum([savedDataRatios[gi][j][i] for j in range (successntrialsperg[gi])])/successntrialsperg[gi]
            f.write("\t{:.2g}\t{:.2g}\t{:.3g}".format(ntemp,stemp,rtemp))
        f.write("\n")
    endtime = time.time()
    total_seconds = endtime-starttime
    hours = int(total_seconds // 3600)
    minutes = int((total_seconds % 3600) // 60)
    seconds = total_seconds % 60
    f.write(f"\nTime taken: {hours} hours, {minutes} minutes, {seconds:.2g} seconds\n")            
    f.close()        
    if densityof2Ns != "fixed2Ns":
        gf = open(gvalsfor2Dplotsnames,'w')
        for gi,g in enumerate(gvals):
            gf.write("{}\t".format(g[0]))
            for i in range(len(allgresults[gi][0])):
                gf.write("{} ".format(allgresults[gi][0][i]))
            gf.write("\n")
            gf.write("{}\t".format(g[1]))
            for i in range(len(allgresults[gi][1])):
                gf.write("{} ".format(allgresults[gi][1][i]))
            gf.write("\n\n")                
        gf.close()
        twoDboxplot.make2Dboxplot(allgresults,gvals,"{} term 1".format(densityof2Ns,nc,foldstring),"{} term 2".format(densityof2Ns,nc,foldstring),plotfile2Dname, False)
        term1vals = []
        term2vals = []
        for gi,g in enumerate(gvals):
            term1vals.append(float(g[0]))
            term2vals.append(float(g[1]))
        fig, ax = plt.subplots()
        ax.boxplot(ln1results,showmeans=True,sym='',positions=term1vals)
        plt.xlabel("{} term 1".format(densityof2Ns,nc,foldstring))
        plt.ylabel("Estimates")
        # plt.plot(gvals,gvals)
        plt.plot(term1vals,term1vals)
        plt.savefig(plotfile1name)
        plt.clf
        fig, ax = plt.subplots()
        ax.boxplot(ln2results,showmeans=True,sym='',positions=term2vals)
        plt.xlabel("{} term 2".format(densityof2Ns,nc,foldstring))
        plt.ylabel("Estimates")
        # plt.plot(gvals,gvals)
        plt.plot(term2vals,term2vals)
        plt.savefig(plotfile2name)
        plt.clf
    else:
        gf = open(gvalsforplotnames,'w')
        for gi,g in enumerate(gvals):
            gf.write("{}\t".format(g[0]))
            for i in range(len(gresults[gi])):
                gf.write("{} ".format(gresults[gi][i]))
            gf.write("\n\n")                
        gf.close()            
        tempgvals = []
        for gi,g in enumerate(gvals):
            tempgvals.append(float(g[0]))
        fig, ax = plt.subplots()
        ax.boxplot(gresults,showmeans=True,sym='',positions=tempgvals)
        plt.xlabel("g (selection)")
        plt.ylabel("Estimates")
        plt.plot(tempgvals,tempgvals)
        plt.savefig(plotfilename)
        plt.clf            
    print("done {}".format(basename))    


def parsecommandline():
    parser = argparse.ArgumentParser()
    parser.add_argument("-c",dest="fix_theta_ratio",default=None,type=float,help="set the fixed value of thetaS/thetaN")
    parser.add_argument("-b",dest="dualannealopt",action="store_true",default=False,help="run the dual annealing optimizer after the regular optimizer")
    parser.add_argument("-d",dest="densityof2Ns",default = "fixed2Ns",type=str,help="gamma or lognormal, only if simulating a distribution of Ns, else single values of Ns are used")
    parser.add_argument("-f",dest="foldstatus",required=True,help="usage regarding folded or unfolded SFS distribution, 'isfolded', 'foldit' or 'unfolded' ")    
    parser.add_argument("-i",dest="optimizetries",type=int,default=1,help="run the minimize optimizer # times, default is once")
    parser.add_argument("-k",dest="ntrials",default = 20, type = int, help="number of trials per parameter set")    
    parser.add_argument("-l",dest="plotfilelabel",default = "", type=str, help="optional string for labelling plot file names ")    
    parser.add_argument("-m",dest="max2Ns",default=1.0,type=float,help="maximum 2Ns, default = 1  ")
    parser.add_argument("-n",dest="nc",type = int, required=True,help="# of sampled chromosomes  i.e. 2*(# diploid individuals)  ")
    if JH_turn_off_options_for_release == False:
        parser.add_argument("-p",dest = "use_misspec",action="store_true",default = False,help="include a misspecification parameter (only for unfolded data)")
        parser.add_argument("-a",dest="thetaNspacerange",default=100,type=int,help="optional setting for the range of thetaNspace, alternatives e.g. 25, 400")
        parser.add_argument("-q",dest="thetaS",type=float,default = None,help = "theta for selected sites")   
    parser.add_argument("-s",dest="seed",type = int,help = " random number seed (positive integer)",default=1)
    if JH_turn_off_options_for_release == False:
        parser.add_argument("-t",dest="thetaN",type=float,default = None,help = "set theta for neutral sites, optional, if -t is not specified then thetaN and thetaS are given by -q")
        parser.add_argument("-w",dest="use_theta_ratio",action="store_false",default=True,help="do not estimate both thetas, just the ratio")  
    parser.add_argument("-D",dest="DEBUGMODE",action="store_true",default=False,help="debug")
    if JH_turn_off_options_for_release == False:
        parser.add_argument("-F", dest="csfsprefix",default = None,type = str, help="optional prefix for csfs filenames,  e.g. Afr, Eur or EAs")
    if JH_turn_off_options_for_release == False:
        parser.add_argument("-M",dest="maxi",default=None,type=int,help="optional setting for the maximum bin index to include in the calculations")
    parser.add_argument("-O", dest="output_dir",default = "./Results_SFS_with_SLiM",type = str, help="Path for output directory")
    parser.add_argument("-W", dest="slim_SFSs_dir",required=True,type = str, help="Path for directory with simulations from Simulate_SFS_with_SLiM.py")
        
    args  =  parser.parse_args(sys.argv[1:])  
    if JH_turn_off_options_for_release:
        args.use_misspec = False
        args.thetaS = None
        args.thetaN = None
        args.use_theta_ratio = True 
        args.csfsprefix = None
        args.maxi = None
        args.thetaNspacerange = 100
    
    if args.densityof2Ns != "fixed2Ns" and not (args.densityof2Ns in ['lognormal','gamma']):
        parser.error("-d term {} is not either 'lognormal' or 'gamma'".format(args.densityof2Ns))
    if args.densityof2Ns== "fixed2Ns" and args.max2Ns != 1.0:
        parser.error("-m requires that a density function be specified (i.e. -d )")    
    if args.foldstatus not in ("isfolded","foldit","unfolded"):
        parser.error("-f {} is wrong,  this tag requires one of 'isfolded','foldit', or 'unfolded'".format(args.foldstatus))
    if args.use_misspec and args.foldstatus != "unfolded":
        parser.error(" use of misspecification (-p) requires that -f be unfolded")
    args.commandstring = " ".join(sys.argv[1:])
    return args

    # return parser

if __name__ == '__main__':
    """

    """
    starttime = time.time()
    args = parsecommandline()
    run(args)
